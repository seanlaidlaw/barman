#' @title barman
#'
#' @description plots UMAP of a filtered and normalized SingleCellExperiement object
#'
#' @param normalised_SCE_object a filtered and normalized SingleCellExperiement, like the type returned from running filter_and_normalise_scRNA() with the return_sce=T parameter.
#' @param umap_vars a vector of colnames from annotation table, to manually specifiy colour_by and size_by values respectively
#' @param regress_out a vector of colnames from annotation table, to regress out of dataset before plotting
#'
#' @return ggplot2 object of UMAP
#'
#' @export


plot_rna_clusters <- function(normalised_SCE_object, regress_out=FALSE, umap_vars=FALSE) {

	if (regress_out != FALSE) {
		normalised_SCE_object <- Seurat::ScaleData(object = Seurat::as.Seurat(normalised_SCE_object), vars.to.regress = "log10_total_features_by_counts")
		normalised_SCE_object <- Seurat::as.SingleCellExperiment(normalised_SCE_object)
	}

	print(scater::plotExplanatoryPCs(normalised_SCE_object, npcs_to_plot = 5))

	# If no variables specified for plotting UMAP then try to guess the most
	# important variable by removing autogenerated ones and chose top
	# variable for PC1 and PC2
	explanatory_PCs_table = scater::getExplanatoryPCs(normalised_SCE_object, use_dimred = "UMAP", ncomponents = 3)
	explanatory_PCs_table = as.data.frame(explanatory_PCs_table)
	pc_vars_table = explanatory_PCs_table
	for (i in colnames(pc_vars_table)) {
		if (length(unique(pc_vars_table[[i]])) == 1) {
			pc_vars_table[[i]] = NULL
		}
	}
	for (i in colnames(explanatory_PCs_table)) {
		if (length(unique(explanatory_PCs_table[[i]])) == 1) {
			explanatory_PCs_table[[i]] = NULL
		}
		if (grepl("log10_",i)) {
			explanatory_PCs_table[[i]] = NULL
		} else if  (grepl("pct_counts",i)) {
			explanatory_PCs_table[[i]] = NULL
		} else if (grepl("total_",i)) {
			explanatory_PCs_table[[i]] = NULL
		}
	}
	explanatory_PCs_table = as.data.frame(t(explanatory_PCs_table))
	pc1_major_var = rownames(explanatory_PCs_table[order(explanatory_PCs_table$PC1, decreasing = T),])[1]
	pc2_major_var = rownames(explanatory_PCs_table[order(explanatory_PCs_table$PC2, decreasing = T),])[1]


	# if only one var given
	if (umap_vars != FALSE) {
		if (length(umap_vars) == 1) {
				pc1_major_var = umap_vars
			}	else {
				pc1_major_var = umap_vars[1]
				pc2_major_var = umap_vars[2]
		}
	}

	i = 0
	while (pc2_major_var == pc1_major_var) {
		# we dont want shape and color to be same variable so pick next one if PC1 and PC2 driven by same var
		pc2_major_var = rownames(explanatory_PCs_table[order(explanatory_PCs_table$PC2, decreasing = T),])[i+1]
		i = i + 1
	}

	print(scater::plotUMAP(
    normalised_SCE_object,
    colour_by = pc1_major_var,
    size_by = pc2_major_var))
}
