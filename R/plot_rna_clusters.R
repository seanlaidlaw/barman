#' @title plot_rna_clusters
#'
#' @description plots UMAP of a filtered and normalized SingleCellExperiement object
#'
#' @param normalised_counts_matrix a filtered, normalized, and log transformed counts matrix
#' @param annotation_table a table of cell annotations, with  rows corresponding to colnames in normalised_counts_matrix
#' @param umap_vars a vector of 2 colnames from annotation table, to manually specifiy the plot's colour and size values respectively
#'
#' @return ggplot2 object of UMAP
#'
#' @export


plot_rna_clusters <- function(normalised_counts_matrix, annotation_table, umap_vars=FALSE) {

	# trim metadata columns from counts matrix
	trimmed_counts_matrix = normalised_counts_matrix
	rownames(trimmed_counts_matrix) = trimmed_counts_matrix$Geneid
	trimmed_counts_matrix$Geneid = NULL
	trimmed_counts_matrix$Chr = NULL
	trimmed_counts_matrix$Start = NULL
	trimmed_counts_matrix$End = NULL
	trimmed_counts_matrix$Strand = NULL
	trimmed_counts_matrix$Length = NULL

	# trim annotation table to be same as counts matrix
	annotation_table = annotation_table[rownames(annotation_table) %in% colnames(trimmed_counts_matrix),]

	# construct SingleCellExperiment object from normalized tables
	normalised_SCE_object <- SingleCellExperiment::SingleCellExperiment(
		assays = list(logcounts = as.matrix(trimmed_counts_matrix)),
		colData = annotation_table
	)


	print(scater::plotExplanatoryPCs(normalised_SCE_object, npcs_to_plot = 5))

	# If no variables specified for plotting UMAP then try to guess the most
	# important variable by removing autogenerated ones and chose top
	# variable for PC1 and PC2
	explanatory_PCs_table = scater::getExplanatoryPCs(normalised_SCE_object, use_dimred = "UMAP", ncomponents = 3)
	explanatory_PCs_table = as.data.frame(explanatory_PCs_table)
	pc_vars_table = explanatory_PCs_table
	for (i in colnames(pc_vars_table)) {
		if (length(unique(pc_vars_table[[i]])) == 1) {
			pc_vars_table[[i]] = NULL
		}
	}
	for (i in colnames(explanatory_PCs_table)) {
		if (length(unique(explanatory_PCs_table[[i]])) == 1) {
			explanatory_PCs_table[[i]] = NULL
		}
		if (grepl("log10_",i)) {
			explanatory_PCs_table[[i]] = NULL
		} else if  (grepl("pct_counts",i)) {
			explanatory_PCs_table[[i]] = NULL
		} else if (grepl("total_",i)) {
			explanatory_PCs_table[[i]] = NULL
		}
	}
	explanatory_PCs_table = as.data.frame(t(explanatory_PCs_table))
	pc1_major_var = rownames(explanatory_PCs_table[order(explanatory_PCs_table$PC1, decreasing = T),])[1]
	pc2_major_var = rownames(explanatory_PCs_table[order(explanatory_PCs_table$PC2, decreasing = T),])[1]


	# if only one var given
	if (umap_vars != FALSE) {
		if (length(umap_vars) == 1) {
				pc1_major_var = umap_vars
			}	else {
				pc1_major_var = umap_vars[1]
				pc2_major_var = umap_vars[2]
		}
	}

	i = 0
	while (pc2_major_var == pc1_major_var) {
		# we dont want shape and color to be same variable so pick next one if PC1 and PC2 driven by same var
		pc2_major_var = rownames(explanatory_PCs_table[order(explanatory_PCs_table$PC2, decreasing = T),])[i+1]
		i = i + 1
	}

	print(scater::plotUMAP(
    normalised_SCE_object,
    colour_by = pc1_major_var,
    size_by = pc2_major_var))
}
