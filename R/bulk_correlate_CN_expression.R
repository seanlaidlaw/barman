#' @title bulk_correlate_CN_expression
#'
#' @description Writes tables of RNA expression and DNA copy number for each gene, from each cell.
#'
#' @param normalised_counts_matrix a normalised counts matrix. Must contain metadata columns
#' like featurecounts matrix.
#' @param dna_segments_dir a folder containing cell-specific segmentation files produced by scCNV (or from
#' ASCAT.summary.csv if converted with the ascat2sccnvsegfunction).
#' @param output_dir output directory to store tables correlating expression to copy number for each
#' gene
#'
#' @return NA
#'
#' @export
bulk_correlate_CN_expression = function(normalised_counts_matrix, dna_segments_dir, output_dir) {

	# sanity check inputs
	if (length(list.files(dna_segments_dir)) < 1) {
		stop("dna_segments_dir argument contains no files")
	}
	if (!all(c("Start","End","Chr") %in% colnames(normalised_counts_matrix))) {
		stop("provided counts matrix does not contain either Start/End/Chr column")
	}



	# remove standard filename additions to isolate cell_ids from filenames of DNA segments
	sample_ids <- c()
	for (file in list.files("scCNV_segments/")) {
	  sample_ids <- append(sample_ids,
	  					 gsub("(_from_DNA_segments.tsv)|(-PCF-kmin.*copynumber.refLOCUS.NA.txt)", "",
	  					 	 gsub("(SEGMENTSlogR.GCcorrected-M30-)|(RNAsegments_)", "",
	  					 	sub('\\.([a-zA-Z]+)$',"",file, perl=T) )),
	  					 length(sample_ids))
	}


	# for each cell id, get counts matrix column and DNA segment file
	for (sample_name in sample_ids) {
		# regex here excludes number after pattern so as to have '"HCC38_5" match only "HCC38_5.txt" and not also "HCC38_51.txt"
		dna_seg_filename <- list.files(dna_segments_dir)[grepl(paste0(".*?", sample_name, "[^0-9].*"), list.files(dna_segments_dir))]

		if (length(dna_seg_filename) == 1) {
			dna_seg_path = paste0(dna_segments_dir, "/", dna_seg_filename)
			dna_seg <- read.table(dna_seg_path, header = T, sep = "\t", stringsAsFactors = F )

			rna_column <- colnames(normalised_counts_matrix)[grepl(paste0(".*?", sample_name, ".*"), colnames(normalised_counts_matrix))]

			# make sure column with cell_id exists
			if (length(rna_column) > 0) {
				if  (rna_column %in% colnames(normalised_counts_matrix)) {

					rna_seg <- subset(normalised_counts_matrix, select = c(rna_column, "Start", "End", "Chr"))
					rownames(rna_seg) = normalised_counts_matrix$Geneid

					# initialise empty columns next to subset counts matrix to put DNA CN info
					rna_seg$rawCN = NA
					rna_seg$pcfCN = NA

					# for each gene in counts matrix workout the average CN from DNA segments that start between start and end of gene
					for (i in 1:nrow(rna_seg)) {
						row <- rna_seg[i, ]

						subset_dnaseg = dna_seg[((row$Chr == dna_seg$Chr) & (row$End >= dna_seg$Pos) & (row$End <= dna_seg$end)), ]

						if (dim(subset_dnaseg)[1] == 1) {
							rna_seg[i, "rawCN"] = round(mean(subset_dnaseg$rawCN))
							rna_seg[i, "pcfCN"] = round(mean(subset_dnaseg$segmentedCN))
						}
					}

					# format matrix of expression and CN to write to file
					rna_seg$Start = NULL
					rna_seg$End = NULL
					colnames(rna_seg)[1] = "Expression"
					rna_seg$Geneid = rownames(rna_seg)
					rna_seg = rna_seg[,c("Geneid", "Chr", "Expression", "rawCN", "pcfCN")]

					if (!dir.exists(output_dir)) {
						dir.create(path = output_dir, showWarnings = F, recursive = T)
					}

					# print header so to sanity check IDs from RNA and DNA
					output_filename = paste0(output_dir, "/", rna_column, "_expr_CN.tsv")
					output_file_header = paste0("# Expression to CN table generated by barman::bulk_correlate_CN_expression()\n# Table generated from matching counts matrix column: ", rna_column, " with DNA segment file: ", dna_seg_filename)
					cat(output_file_header, file = output_filename, sep = "\n")

					# write expression/CN matrix to table
					write.table(x = rna_seg, file = output_filename, sep = "\t", row.names = F, col.names = T, append = T)
				}
			}
		}
	}
}
