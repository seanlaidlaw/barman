#' @title infer_signif_annot_cols
#'
#' @description infers what Principal Components should be analysed. Determines what columns in
#' annotation table represent the highest variance in the normalised counts matrix
#'
#' @param normalised_counts_matrix a filtered, normalized, and log transformed counts matrix
#' @param annotation_table a table of cell annotations, with  rows corresponding to colnames in normalised_counts_matrix
#'
#' @return a vector of annotation_table column names
#'
#' @export


infer_signif_annot_cols <- function(normalised_counts_matrix, annotation_table) {
	annotation_table_cols = colnames(annotation_table)

	# trim metadata columns from counts matrix
	trimmed_counts_matrix = normalised_counts_matrix
	rownames(trimmed_counts_matrix) = trimmed_counts_matrix$Geneid
	trimmed_counts_matrix$Geneid = NULL
	trimmed_counts_matrix$Chr = NULL
	trimmed_counts_matrix$Start = NULL
	trimmed_counts_matrix$End = NULL
	trimmed_counts_matrix$Strand = NULL
	trimmed_counts_matrix$Length = NULL

	# trim annotation table to be same as counts matrix
	annotation_table = annotation_table[rownames(annotation_table) %in% colnames(trimmed_counts_matrix),]
	annotation_table = as.data.frame(annotation_table)
	colnames(annotation_table) = annotation_table_cols


	# construct SingleCellExperiment object from normalized tables
	normalised_SCE_object <- SingleCellExperiment::SingleCellExperiment(
		assays = list(logcounts = as.matrix(trimmed_counts_matrix)),
		colData = annotation_table
	)


	# guess most important variable by removing autogenerated ones and chose top
	# variable for PC1 and PC2
	explanatory_PCs_table = scater::getExplanatoryPCs(normalised_SCE_object, use_dimred = "UMAP", ncomponents = 3)
	explanatory_PCs_table = as.data.frame(explanatory_PCs_table)
	pc_vars_table = explanatory_PCs_table
	for (i in colnames(pc_vars_table)) {
		if (length(unique(pc_vars_table[[i]])) == 1) {
			pc_vars_table[[i]] = NULL
		}
	}
	for (i in colnames(explanatory_PCs_table)) {
		if (length(unique(explanatory_PCs_table[[i]])) == 1) {
			explanatory_PCs_table[[i]] = NULL
		}
		if (grepl("log10_",i)) {
			explanatory_PCs_table[[i]] = NULL
		} else if  (grepl("pct_counts",i)) {
			explanatory_PCs_table[[i]] = NULL
		} else if (grepl("total_",i)) {
			explanatory_PCs_table[[i]] = NULL
		}
	}
	explanatory_PCs_table = as.data.frame(t(explanatory_PCs_table))
	pc1_major_var = rownames(explanatory_PCs_table[order(explanatory_PCs_table$PC1, decreasing = T),])[1]
	pc2_major_var = rownames(explanatory_PCs_table[order(explanatory_PCs_table$PC2, decreasing = T),])[1]


	pc_list = rownames(explanatory_PCs_table[order(explanatory_PCs_table$PC1, decreasing = T),])
	if (length(pc_list) > 1) {
		i = 0
		while (pc2_major_var == pc1_major_var) {
			# we dont want shape and color to be same variable so pick next one if PC1 and PC2 driven by same var
			pc2_major_var = rownames(explanatory_PCs_table[order(explanatory_PCs_table$PC2, decreasing = T),])[i+1]
			i = i + 1
		}

		inferred_PCs = c(pc1_major_var, pc2_major_var)
	} else {
		inferred_PCs = c(pc1_major_var)
	}

	return(inferred_PCs)
}
